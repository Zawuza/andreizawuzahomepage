<h1>Selbstgeschriebene Factories und IoC-Containers</h1>
<P>Heute möchte ich über einen Trick sprechen, der mich in den letzten Wochen zu denken gezwungen hat. Das ist die Registrierung
    im initialization-Sektion. Ich fand den Trick interessant und möchte die Vorteile und Nachteile davon zeigen. Bevor ich
    beginne, muss ich sagen, dass es nicht um die "Turnkey"-Lösungen, wie zum Beispiel Spring4D.</p>
<h3>Was ist die Registrierung in der initialization-Sektion</h3>
<p>Die Registrierung bei der Initialisierung ist eine ganz verbreitete in der Delphi-Welt Technik. Man erzeugt eine Fabrik beim
    Start des Programms. In den Modulen, wo sich die Klassen befinden, die in der Fabrik registriert sein sollen, schreibt
    man in der Sektion "initialization" eine Registrierungsmethode. Beispiel:</p>
<p>Das Modul mit der Fabrik:</p>
<script src='http://pastebin.com/embed_js/NzKZgv8U'></script>
<p>Das Modul mit den Beispielen der Klassen:</p>
<script src='http://pastebin.com/embed_js/jxrCT1Uf'></script>
<p>Beim Start des Programms wird TMySuperClass in der Fabrik gespeichert. Das ist echt cool, weil das eine Dependency-Inversion
    ist. Man kann die gespeicherte Klasse so nutzen:</p>
<script src='http://pastebin.com/embed_js/XAEZKr2Z'></script>
<p>Wenn ich diesen Trick zum ersten Mal gesehen habe, war ich echt überrascht. Die Schönheit dieser Technik hat mich aufgeregt
    gemacht, aber ich habe auch ganz schnell die Nachteile gemerkt. Und deswegen habe ich mich entschieden diesen Post zu
    schreiben, damit ich mit dieser Technik klarkommen kann und gut verstehen kann, wann man es nutzen soll und wann nicht.
</p>
<h3>Speicherverbrauch</h3>
<p>Die Fabriken sind im Prinzip nicht so groß (bei der richtigen Architektur, natürlich) und der Speicherverbrauch soll nicht
    so groß sein. Es kann aber passieren, wenn die Fabriken sehr viel Klassen enthalten, dass der Speicherverbrauch zunimmt.
    Das passiert aber selten. Ich denke, dass der Speicherverbrauch kein Nachteil der Fabriken ist.
</p>
<h3>Ausführungszeit</h3>
<p>Hier liegt alles an der Hand: die Zeit des Startes von dem Program wird lagsamer, aber die Ausführungs wird
    schneller, weil wir alles vorher vorbereitet haben.
</p>
<h3>Lesbarkeit und Schönheit des Codes</h3>
<p> Der Vorteil der Nutzung der Fabriken ist, dass wir die Inversion von den Abhängigkeiten schaffen, was die Kopplung
    des Codes verringert. Dazu sollen wir nie den Code der Fabrik verändern, um neue Objekten in dieser Fabrik
    registrieren. Das heißt, dass wir auch dem Open Closed Prinzip folgen. Von der anderen Seite, wir sollen ein
    Singleton erzeugen. Da riecht der Code ein bisschen schon.
</p>
<h3>Singletone</h3>
<p>Die Erzeugung des Singletones bedeutet für uns, dass wir eine globale Instanz konstruieren. Die globalen Variablen
   erzeugt man meistens nicht, die Singletones sind aber noch da. Es gibt eine Vielzahl von den Argumenten, warum man
   nie in seinem Leben Singleton erzeugen soll. Die Gründe sind manchmal für uns nicht so relevant. Unter dem
   Link (auf stackoverflow) sind einige Gründe geschrieben:
</p>
<ul>
    <li>Die Singletons brechen den Single Responsibility Prinzip, weil sie selbst das eigene Leben kontrollieren.
        Ich finde es nicht logisch, denn im Beispiel oben sind die Singletons von einer Funktion und finalization-Sektion
        kontrolliert.   
    </li>
    <li>Singletons(oder Singletöne?) sind schlecht, weil die schwer sich parallelisieren lassen. Im Kontext der 
        Desktopanwendungen ist es meistens nicht der Fall und alle Parallelisierungsprobleme sich dur einen Mutex
        lösen lassen. Wenn die Anzahl der Threads erhöht sich, dann können schon die Probleme entstehen.
    </li>
</ul>
<h2>Die Übersetzung läuft noch :)</h2>
<h3>Inspiriert durch:</h3>
<ul>
    <li><a href='http://www.devtrends.co.uk/blog/how-not-to-do-dependency-injection-the-static-or-singleton-container'>http://www.devtrends.co.uk/blog/how-not-to-do-dependency-injection-the-static-or-singleton-container</a></li>
    <li><a href='http://www.ibm.com/developerworks/library/co-single/'>http://www.ibm.com/developerworks/library/co-single/</a></li>
    <li><a href='http://stackoverflow.com/questions/137975/what-is-so-bad-about-singletons'>http://stackoverflow.com/questions/137975/what-is-so-bad-about-singletons</a></li>
    <li><a href='http://misko.hevery.com/2008/10/21/dependency-injection-myth-reference-passing/'>http://misko.hevery.com/2008/10/21/dependency-injection-myth-reference-passing/</a></li>
    <li><a href='http://robstechcorner.blogspot.de/2009/09/exploring-trttitype-and-descendants-in.html'>http://robstechcorner.blogspot.de/2009/09/exploring-trttitype-and-descendants-in.html</a></li>
    <li><a href='http://stackoverflow.com/questions/10613094/how-can-i-make-sure-rtti-is-available-for-a-class-without-instantiating-it/10613212#10613212'>http://stackoverflow.com/questions/10613094/how-can-i-make-sure-rtti-is-available-for-a-class-without-instantiating-it/10613212#10613212</a></li>
</ul>