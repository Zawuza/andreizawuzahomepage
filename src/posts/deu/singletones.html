<h1>Selbstgeschriebene Factories und IoC-Containers</h1>
<P>Heute möchte ich über einen Trick sprechen, der mich in den letzten Wochen zu denken gezwungen hat. Das ist die Registrierung
    im initialization-Sektion. Ich fand den Trick interessant und möchte die Vorteile und Nachteile davon zeigen. Bevor ich
    beginne, muss ich sagen, dass es nicht um die "Turnkey"-Lösungen, wie zum Beispiel Spring4D.</p>
<h3>Was ist die Registrierung in der initialization-Sektion</h3>
<p>Die Registrierung bei der Initialisierung ist eine ganz verbreitete in der Delphi-Welt Technik. Man erzeugt eine Fabrik beim
    Start des Programms. In den Modulen, wo sich die Klassen befinden, die in der Fabrik registriert sein sollen, schreibt
    man in der Sektion "initialization" eine Registrierungsmethode. Beispiel:</p>
<p>Das Modul mit der Fabrik:</p>
<script src='http://pastebin.com/embed_js/NzKZgv8U'></script>
<p>Das Modul mit den Beispielen der Klassen:</p>
<script src='http://pastebin.com/embed_js/jxrCT1Uf'></script>
<p>Beim Start des Programms wird TMySuperClass in der Fabrik gespeichert. Das ist echt cool, weil das eine Dependency-Inversion
    ist. Man kann die gespeicherte Klasse so nutzen:</p>
<script src='http://pastebin.com/embed_js/XAEZKr2Z'></script>
<p>Wenn ich diesen Trick zum ersten Mal gesehen habe, war ich echt überrascht. Die Schönheit dieser Technik hat mich aufgeregt
    gemacht, aber ich habe auch ganz schnell die Nachteile gemerkt. Und deswegen habe ich mich entschieden diesen Post zu
    schreiben, damit ich mit dieser Technik klarkommen kann und gut verstehen kann, wann man es nutzen soll und wann nicht.
</p>
<h3>Speicherverbrauch</h3>
<p>Die Fabriken sind im Prinzip nicht so groß (bei der richtigen Architektur, natürlich) und der Speicherverbrauch soll auch nicht
    so groß sein. Es kann aber passieren, wenn die Fabriken sehr viel Klassen enthalten, dass der Speicherverbrauch zunimmt.
    Das passiert aber selten. Ich denke, dass der Speicherverbrauch kein Nachteil der Fabriken ist.
</p>
<h3>Ausführungszeit</h3>
<p>Hier liegt alles an der Hand: die Zeit des Startes von dem Program wird lagsamer, aber die Ausführungs wird
    schneller, weil wir alles vorher vorbereitet haben.
</p>
<h3>Lesbarkeit und Schönheit des Codes</h3>
<p> Der Vorteil der Nutzung der Fabriken ist, dass wir die Inversion von den Abhängigkeiten schaffen, was die Kopplung
    des Codes verringert. Dazu sollen wir nie den Code der Fabrik verändern, um neue Objekten in dieser Fabrik
    registrieren. Das heißt, dass wir auch dem Open Closed Prinzip folgen. Von der anderen Seite, wir sollen ein
    Singleton erzeugen. Da riecht der Code ein bisschen schon.
</p>
<h3>Singletone</h3>
<p>Die Erzeugung des Singletones bedeutet für uns, dass wir eine globale Instanz konstruieren. Die globalen Variablen
   erzeugt man meistens nicht, die Singletones sind aber noch da. Es gibt eine Vielzahl von den Argumenten, warum man
   nie in seinem Leben Singleton erzeugen soll. Die Gründe sind manchmal für uns nicht so relevant. Unter dem
   Link (auf stackoverflow) sind einige Gründe geschrieben:
</p>
<ul>
    <li>Die Singletons brechen den Single Responsibility Prinzip, weil sie selbst das eigene Leben kontrollieren.
        Ich finde es nicht logisch, denn im Beispiel oben sind die Singletons von einer Funktion und finalization-Sektion
        kontrolliert.   
    </li>
    <li>Singletons(oder Singletöne?) sind schlecht, weil die schwer sich parallelisieren lassen. Im Kontext der 
        Desktopanwendungen ist es meistens nicht der Fall und alle Parallelisierungsprobleme sich dur einen Mutex
        lösen lassen. Wenn die Anzahl der Threads erhöht sich, dann können schon die Probleme entstehen.
    </li>
</ul>
<p> Die folgenden Gründe finde ich wichtig:
</p>
<ul>
    <li>Es ist schwer, Singletons zu testen
    </li>
    <li>Singletons verstecken die Abhängigkeiten der Anwendung
    </li>
</ul>
<h3>Testen der Fabriken</h3>
<p> Im Prinzip, es ist möglich. Man kann ein Testmodul erstellen, wo eine Klasse geschrieben wird, die während
    des Testverfahrens genutzt wird. Das ist ein Vorteil von den Fabriken. Unsere Fabriken sind gleichzeitig auch 
    IoC-Containers und das ist gut. Es ist aber schwer, die Fabrik selbst zu ersetzen. Dafür kann man ein Interface schreiben.
</p>
<script src='http://pastebin.com/embed_js/qUtSPPLP'></script>
<p> Ich bin der Meinung, dass eine Vorfahrklasse (oder Interface) für den Contaner zu schreiben eine gute Idee ist! Es ist
    aber nicht besonders einfach.
</p>
<p>Es gibt noch ein Problem, das eher Delphi-bezogen ist. Es war mir früher nicht bekannt, dass die initialization-Sektion nur 
    dann ausgeführt wird, wenn man das Modul mit der Sektion in Uses von dem Hauptprogramm schreibt. Das ist manchmal unangenehm,
    wenn ich, zum Beispiel, die Module durch Suchpfad angebe. Alle diese Module, die nicht direkt zu dem Projekt hinzugefügt wurden,
    soll man mit der Hand in das Hauptprogramm schreiben. Machmal ist es auch angenehm, zum Beispiel, wenn man zum Testen nicht alle Klassen
    in die Fabrik lädt. Aber was soll man tun, wenn man in mehreren Tests verschiede Klassen braucht?
</p>
<p>
    So, der Argument, dass die Fabrike schwer zu testen sind, ist ziemlich bestreitbar, aber ich denke, dass man etwas besser ausdenken kann, 
    wenn man echt viele Tests machen will.
</p>
<h2>Die Übersetzung läuft noch :)</h2>
<h3>Inspiriert durch:</h3>
<ul>
    <li><a href='http://www.devtrends.co.uk/blog/how-not-to-do-dependency-injection-the-static-or-singleton-container'>http://www.devtrends.co.uk/blog/how-not-to-do-dependency-injection-the-static-or-singleton-container</a></li>
    <li><a href='http://www.ibm.com/developerworks/library/co-single/'>http://www.ibm.com/developerworks/library/co-single/</a></li>
    <li><a href='http://stackoverflow.com/questions/137975/what-is-so-bad-about-singletons'>http://stackoverflow.com/questions/137975/what-is-so-bad-about-singletons</a></li>
    <li><a href='http://misko.hevery.com/2008/10/21/dependency-injection-myth-reference-passing/'>http://misko.hevery.com/2008/10/21/dependency-injection-myth-reference-passing/</a></li>
    <li><a href='http://robstechcorner.blogspot.de/2009/09/exploring-trttitype-and-descendants-in.html'>http://robstechcorner.blogspot.de/2009/09/exploring-trttitype-and-descendants-in.html</a></li>
    <li><a href='http://stackoverflow.com/questions/10613094/how-can-i-make-sure-rtti-is-available-for-a-class-without-instantiating-it/10613212#10613212'>http://stackoverflow.com/questions/10613094/how-can-i-make-sure-rtti-is-available-for-a-class-without-instantiating-it/10613212#10613212</a></li>
</ul>