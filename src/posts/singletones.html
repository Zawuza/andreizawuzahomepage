<h1>Самописные фабрики и IoC контейнеры</h1>
  <P>Сегодня я хочу поговорить о технике, которая беспокоит меня последние месяцы. Все дело в том, что я узнал о регистрации при
    инициализации модулей. Трюк показался мне довольно интересным, и я хочу поподробнее рассмотреть его со всех сторон. Должен
    заметить, что речь не пойдет о готовых решениях, в роде Spring4D, а о самописных фабриках и контейнерах в коде.</p>
  <h3>Что такое регистрация при инициализации модулей</h3>
  <p>Регистрация при инициализации модулей – это довольно часто применяющийся в дельфи прием. Его смысл в том, что есть класс-фабрика,
    создающийся при запуске программы. При этом в модулях, где содержатся классы, которые должны быть присоединены к этой
    фабрике, в секции инициализации вызывается метод регистрации. Лучше всего объяснить это на примере:</p>
  <p>Модуль с самой фабрикой:</p>
  <script src='http://pastebin.com/embed_js/NzKZgv8U'></script>
  <p>Модуль с примерами классов:</p>
  <script src='http://pastebin.com/embed_js/jxrCT1Uf'></script>
  <p>При старте программы TMySuperClass зарегистрирует себя в фабрике. Это круто, потому что это - инверсия зависимостей. А
    использовать это можно так:</p>
  <script src='http://pastebin.com/embed_js/XAEZKr2Z'></script>
  <p>Когда я впервые увидел этот прием, в меня сразу же закрались сомнения, но и отрицать красоту этого решения я не мог. И поэтому
    я решил сделать подробный разбор этого приема, его плюсов и минусов, и решить для себя, когда я буду его применять, а
    когда нет.</p>
  <h3>Использование памяти</h3>
  <p>Классы-фабрики сами по себе занимают не очень много места в памяти (при правильном проектировании, конечно. Если вы будете,
    например, сохранять созданные объекты то да, потребление памяти будет заметное), но, возможно, если их станет много,
    то память будет серьезно тратиться. Но такое происходит редко и на это можно не обращать внимания. Назвать это серьезным
    недостатком нельзя.
  </p>
  <h3>Время исполнения программы</h3>
  <p>Здесь все аргументы лежат на поверхности: время старта программы замедляется, но позже мы получаем прибавку к производительности,
    потому что создали все заранее.</p>
  <h3>Читаемость и красота кода</h3>
  <p>Это несомненный плюс нашего подхода. Во-первых, мы используем инверсию зависимостей, что делает наш код менее связным
    К тому же создание такого рода классов позволяет совершенно не изменять код фабрики для добавления новых элементов в
    фабрику, что хорошо с точки зрения принципа открытости/закрытости. Несомненно, это огромный плюс для создания такого
    рода фабрик. С другой стороны, мы порождаем в коде синглтон, а это уже нехорошо. Код немножечко smells.</p>
  <h3>Синглтон</h3>
  <p>
    Появление такой фабрики означает появление глобального класса, глобальной переменной. Глобальные переменные почему-то никто
    не создает, а вот синглтоны еще приходится. Есть достаточное количество причин, почему создание синглтонов плохо, да
    и многие из них кажутся мне недостаточно убедительными. По указанной в конце статьи ссылке на stackoverflow написаны
    некоторые из них:
  </p>
  <ul>
    <li>Синглтоны нарушают принцип единственной ответственности, потому что они сами контролируют свой жизненный цикл. Спорное
      утверждение, потому что, например, в нашем примере выше его цикл контролируется отдельной функцией и секцией finalization.</li>
    <li>Синглтоны плохи, когда программу нужно распараллелить. В контексте десктопных приложений это не всегда очень важно, и
      все проблемы решаются лишним мьютексом в методах синглтона. При большем количестве потоков мы можем войти в состояние
      гонки, и тогда это будет действительно проблемой</li>
  </ul>
  <p>
    А вот следующие две причины действительно важны, и я рассмотрю их подробнее:
  </p>
  <ul>
    <li>Синглтоны сложны для тестирования</li>
    <li>Синглтоны прячут зависимости в приложении</li>
  </ul>
  <h3>Тестирование фабрик</h3>
  <p>
    В принципе, тестирование фабрик возможно, потому что можно создать отдельный тестовый модуль, в котором будет специальный
    класс для тестов, который и будет зарегистрирован в фабрике. Этот плюс фабрики такого типа берут от контейнеров инверсии
    управления (это я так IoC containers обозвал), которыми они, в принципе, тоже являются. Но нам будет тяжеловато, например,
    подменить саму фабрику. Для того, чтобы сделать это, было бы очень неплохо создать отдельный интерфейс, потому
    что тогда мы сможем заменить фабрику, например, через создание новой функции для доступа.
  </p>
  <script src='http://pastebin.com/embed_js/qUtSPPLP'></script>
  <p>Вообще, создание предка для фабрик, синглтонов и IoC контейнеров является, по моему мнению, хорошей практикой и облегчает
    тестирование. Но все же это не самый простой способ все тестировать.
  </p>
  <p>
    Есть еще один момент, относящийся только к дельфи. Все дело в том, что секция initialization будет исполняться только тогда,
    когда к .dpr файлу с основным телом программы будут подключены все модули, необходимые для регистрации. Что очень неудобно
    для проектов, которые не включают в себя тестируемые модули (а, например, добавляют необходимые модули через search path),
    потому что их приходится вписывать самим. В принципе, это тоже удобно, потому что можно заполнить фабрику только теми
    классами, которые нужны для тестирования. Но что, если проект с тестами один, а в разное время нам нужны разные подключенные
    классы в фабрике?
  </p>
  <p>
    Опять же, аргумент про тестирование очень спорный, но мне кажется, что удобство тут не на стороне фабрики.
  </p>
  <h3>Сокрытие зависимостей</h3>
  <p>
    Вот это, наверное, самый важный для меня аргумент. Скрытые зависимости. Для облегчения понимания происходящего вот пример
    класса, который использует вышеописанную фабрику.
  </p>
  <script src='http://pastebin.com/embed_js/5EeuXYtN'></script>
  <p>
    Например, в этом примере очень тяжело понять, что TConsumerу требуется еще один класс для помощи в выполнении очень важной
    работы. Эта зависимость была спрятана. Это ухужшает восприятие кода, к тому же, метод не будет работать без наличия синглтона
    и объект не может быть в таком случае переиспользован. Но это, по большей части, проблема дизайна, а не фабрики.
  </p>
  <p>
    К тому же, наличие синглтонов осложняет понимание системы. Система перестает делиться на уровни абстракции, потому что синглтон
    не принадлежит к какому-либо уровню из них (хотя его уровень может определяться его назначением). Он существует глобально,
    независимо от всего остального.
  </p>
  <h2>Выходы из сложившейся ситуации</h2>
  <p>
    На самом деле, нужно сказать, что использование IoC-фабрик на самом деле не так уж и плохо, но если все же решено от них
    отказаться, то какие у них есть альтернативы?
  </p>
  <h3>Стратегия</h3>
  <p>
    Первое приходящее на ум решение – перенести регистрацию объектов из initialization модуля в конструктор или специальный метод
    самой фабрики, как здесь:
  </p>
  <script src='http://pastebin.com/embed_js/DSskvz25'></script>
  <p>
    По сути, мы переходим от IoC к паттерну «Стратегия», в котором мы создаем класс-контекст, принимающий решение, какой
    из классов-стратегий применить. Проблема в том, что усложняется и становится неочевидным добавление новых стратегий.
    Плюсом же является то, что стратегия может иметь множество независимых инстансов себя. Этот метод не дает больших
    преимуществ, но позволяет сделать архитектуру более 'слоистой' (разбитую на слои) и позволяет уничтожать фабрику в любой
    момент, а не держать её до закрытия приложения. Но в этом случае мы отказываемся практически от всех преимуществ фабрики.
  </p>
  <h3>Пересмотр дизайна</h3>
  <p>
    Другой интересный вопрос: а нужна ли фабрика вообще? Возможно, если у вас много классов, совершающих похожую работу, то лучше
    создать один класс, который будет читать, например, из базы данных то, что он должен сделать. А если количество классов
    небольшое, то и решение со стратегией подойдет.
  </p>
  <h3>Агрегация на следующем уровне абстракции</h3>
  <p>
    Очень интересный и красивый трюк. В данном случае мы переносим регистрации контейнера на вышестоящий слой. Например, класс
    приложения:
  </p>
  <script src='http://pastebin.com/embed_js/9QVTmuw6'></script>
  <p>
    Как вы уже, скорее всего, подумали, класс приложения не является самым удачным примером. И это так и есть, потому что, если
    необходима фабрика, которая будет работать в течение всей жизни приложения, то проще и удобнее будет создать синглтон
    с регистрацией. Но, например, для внешних библиотек это, наверное, самое лучшее решение. Мы сможем активировать библиотеку,
    работать с ней, а потом завершить работу с ней, освободив все-все-все ресурсы, которые требуются библиотеке.
  </p>
  <p>
    В библиотеке также можно создать отдельный класс, который будут заполнять фабрику. А его, например, наследников (с перегруженными
    методами) можно будет использовать при тестировании.
  </p>
  <h3>RTTI и конфиги</h3>
  <p>
    Итак, теперь, мы можем сделать нашу фабрику заменяемой при помощи абстракции над ней и получили возможность создавать и уничтожать
    ее при надобности, но у нас есть еще одна довольно большая проблема, которая лично для меня делает все вышеперечисленные
    решения не очень чистыми, а скорее заменой одного недостатка на другой – это методы регистрации. Проблема в том, что
    где-то должен в коде лежать список (который иногда довольно большой) тех классов, которые должны быть зарегистрированы.
    Выглядеть он будет примерно так:
  </p>
  <script src='http://pastebin.com/embed_js/Jn6RSAm2'></script>
  <p>
    При регистрации в секции initialization этот недостаток размазывается на множество модулей. И в каждом из них будет пара
    строчек, которые не привлекают к себе большого внимания, в отличие от такого (иногда гигантского) метода. Иногда я задумываюсь
    и не могу решить одну вещь: что хуже: когда у меня такой синглтон или когда у меня такой монстрометод. Так почему не
    вынести тогда этот список из кода в конфигурационный файл? Для этого я написал маленькую консольную программу.
  </p>
  <p>Основной файл программы:</p>
  <script src='http://pastebin.com/embed_js/nKzfDxTh'></script>
  <p>Модуль Factory</p>
  <script src='http://pastebin.com/embed_js/Ky30hdDP'></script>
  <p>Модуль Writers</p>
  <script src='http://pastebin.com/embed_js/EG9r8W7W'></script>
  <p>Модуль ReferenceForcer</p>
  <script src='http://pastebin.com/embed_js/MpmQdy64'></script>
  <p>
    Все хорошо, но что за ForceReference? Все дело в том, что если класс не будет нигде использоваться, то он будет исключен
    из исполняемого файла. Для этого и нужна эта процедура, чтобы линкер не убрал этот класс. Этот хак немного расстроил
    меня, но все же это тоже неплохо.
  </p>
  <h2>Итоги</h2>
  <p>Статья получилась достаточно сумбурная и размытая, без четкого плана, потому что я писал ее достаточно долго, много исправлял,
    сомневался в том, что пишу. Но, в конце-концов, я решил для себя:
  </p>
  <ul>
    <li>Если необходим контейнер, который должен умирать только вместе с приложением и не будет использоваться множеством потоков,
      то я использую синглтон с регистрацией в секции initialization</li>
    <li>Если необходим контейнер для работы в многопоточном окружении или для внешней библиотеки, которая часто вызываться не
      будет, то я буду использовать RTTI и конфиги</li>
    <li>Если плодить конфиги нельзя (или проблемы с RTTI будут слишком сильными), то я буду использовать классы, которые будут
      наполнять мой контейнер необходимыми классами.</li>
  </ul>
  <p>
    В общем, на этом все. Пока что на моем сайте я не реализовал комментарии, поэтому пишите мне каким-нибудь другим способом,
    например, по электронной почте
  </p>
  <h3>Вдохновение</h3>
  <ul>
  <li><a href='http://www.devtrends.co.uk/blog/how-not-to-do-dependency-injection-the-static-or-singleton-container'>http://www.devtrends.co.uk/blog/how-not-to-do-dependency-injection-the-static-or-singleton-container</a></li>
  <li><a href='http://www.ibm.com/developerworks/library/co-single/'>http://www.ibm.com/developerworks/library/co-single/</a></li>
  <li><a href='http://stackoverflow.com/questions/137975/what-is-so-bad-about-singletons'>http://stackoverflow.com/questions/137975/what-is-so-bad-about-singletons</a></li>
  <li><a href='http://misko.hevery.com/2008/10/21/dependency-injection-myth-reference-passing/'>http://misko.hevery.com/2008/10/21/dependency-injection-myth-reference-passing/</a></li>
  <li><a href='http://robstechcorner.blogspot.de/2009/09/exploring-trttitype-and-descendants-in.html'>http://robstechcorner.blogspot.de/2009/09/exploring-trttitype-and-descendants-in.html</a></li>
  <li><a href='http://stackoverflow.com/questions/10613094/how-can-i-make-sure-rtti-is-available-for-a-class-without-instantiating-it/10613212#10613212'>http://stackoverflow.com/questions/10613094/how-can-i-make-sure-rtti-is-available-for-a-class-without-instantiating-it/10613212#10613212</a></li>
  </ul>